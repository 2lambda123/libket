
/* MIT License
 * 
 * Copyright (c) 2020 Evandro Chagas Ribeiro da Rosa <evandro.crr@posgrad.ufsc.br>
 * Copyright (c) 2020 Rafael de Santiago <r.santiago@ufsc.br>
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#pragma once
#include <unordered_map>
#include <unordered_set>
#include <cstdint>
#include <sstream>
#include <memory>
#include <vector>
#include <string>
#include <stack>
#include <stack>
#include <iostream>

//! Main libket namespace.
namespace ket {
    #ifndef SWIG
    class process {
    public:
        enum Gate { x, y, z, h, s, sd, t, td, u1, u2, u3, dump };

        process();

        void exec();

        void add_inst(const std::string& inst);
        void add_gate(Gate gate, size_t qubit, std::vector<double> args = {});

        std::vector<size_t> quant(size_t size, bool dirty);

        std::tuple<size_t, std::shared_ptr<std::int64_t>, std::shared_ptr<bool>>
        measure(const std::vector<size_t>& qubits);  
        std::tuple<size_t, std::shared_ptr<std::int64_t>, std::shared_ptr<bool>>
        new_int(std::int64_t value);
        std::tuple<size_t, std::shared_ptr<std::int64_t>, std::shared_ptr<bool>>
        op_int(size_t left, const std::string& op, size_t right);

        void adj_begin();
        void adj_end();

        void ctrl_begin(const std::vector<size_t>& control);
        void ctrl_end();

        void free(size_t qubit, bool dirty);

        size_t new_label_id();

    private:
        size_t qubit_count, future_count, label_count; 
        
        std::unordered_map<size_t,
                           std::pair<std::shared_ptr<std::int64_t>, 
                                     std::shared_ptr<bool>         >> measure_map;
        std::unordered_set<size_t> qubits_free;
        std::stack<std::stack<std::string>> adj_stack;
        std::vector<std::vector<size_t>> ctrl_stack;  
        std::stringstream kqasm;
    };

    inline std::stack<std::shared_ptr<process>> process_stack;
    inline std::stack<std::shared_ptr<bool>> process_on_top_stack;

    inline std::string kbw_path;
    inline std::string plugin_path;
    inline bool use_plugin; 
    inline bool execute_kqasm;
    inline size_t exec_seed;

    inline std::string kqasm_path;
    inline bool output_kqasm;
    extern "C" void ket_init_new(int argc, char* argv[]) __attribute__((constructor));
    #endif

    /*! \brief Array of qubits references.
     *  \class quant
     */
    struct quant {
        #ifndef SWIG
        quant(const std::vector<size_t> &qubits);
        #endif

        //! Alloc size qubits.
        quant(size_t size);

        //! Alloc size dirty qubits.
        static quant dirty(size_t size);

        #ifndef SWIG
        /*! \brief Return the reference for a single qubit.
         * 
         *  \note
         *      For the Python wrapper use brackets instead.
         */
        quant operator()(int idx) const;

        /*! \brief Return the reference for a range of qubits.
         * 
         *  \note
         *      For the Python wrapper use brackets instead.
         */
        quant operator()(int start, int end, int step = 1) const;
        #endif

        /*! \brief Concatenate two quant.
         * 
         *  \note
         *      The two quant needs to belong to the same process. 
         */
        quant operator|(const quant& other) const;

        //! Return a quant with qubits in the inverted order
        quant inverted() const;

        //! Return the number qubits of the quant
        size_t len() const;
        size_t __len__() const;

        /*! \brief Free the qubits
         * 
         *  \note 
         *      All qubits must be at the state \f$\left|0\right>\f$ before the call,
         *      otherwise set the dirty param to true.
         * 
         *  \warning 
         *      No check is applied to see if the qubits are at state
         *      \f$\left|0\right>\f$.
         */
        void free(bool dirty = false) const;

        #ifndef SWIG
        const std::vector<size_t> qubits;
        const std::shared_ptr<bool> process_on_top;
        #endif
    };

    /*! \brief Refers to a integer generated in a quantum computer.
     *  \class future
     */
    class future {
    public:
        #ifndef SWIG
        future(size_t id,
               const std::shared_ptr<std::int64_t>& result,
               const std::shared_ptr<bool>& available);
        #endif

        //! Initialize a future with a value.
        future(std::int64_t value);

        future operator==(const future& other) const;
        future operator!=(const future& other) const;
        future operator<(const future& other) const;
        future operator<=(const future& other) const;
        future operator>(const future& other) const;
        future operator>=(const future& other) const;

        future operator==(std::int64_t other) const;
        future operator!=(std::int64_t other) const;
        future operator<(std::int64_t  ther) const;
        future operator<=(std::int64_t  other) const;
        future operator>(std::int64_t  ther) const;
        future operator>=(std::int64_t  other) const;

        future operator+(const future& other) const;
        future operator-(const future& other) const;
        future operator*(const future& other) const;
        future operator/(const future& other) const;
        future operator<<(const future& other) const;
        future operator>>(const future& other) const;
        future operator&(const future& other) const;
        future operator^(const future& other) const;
        future operator|(const future& other) const;
        
        future operator+(std::int64_t other) const;
        future operator-(std::int64_t other) const;
        future operator*(std::int64_t other) const;
        future operator/(std::int64_t other) const;
        future operator<<(std::int64_t other) const;
        future operator>>(std::int64_t other) const;
        future operator&(std::int64_t other) const;
        future operator^(std::int64_t other) const;
        future operator|(std::int64_t other) const;

        future __radd__(std::int64_t other) const;
        future __rsub__(std::int64_t other) const;
        future __rmul__(std::int64_t other) const;
        future __rtruediv__(std::int64_t other) const;
        future __rlshift__(std::int64_t other) const;
        future __rrshift__(std::int64_t other) const;
        future __rand__(std::int64_t other) const;
        future __rxor__(std::int64_t other) const;
        future __ror__(std::int64_t other) const;

        /*! \brief Get the integer from the quantum computer.
         *  
         *  \note
         *      This method triggers the quantum execution.
         */
        std::int64_t get();

        //! Set the future value with another future.
        void set(const future& other);

        #ifndef SWIG
        size_t get_id() const;
        const std::shared_ptr<bool> process_on_top;
        #endif

    private:
        size_t id;
        std::shared_ptr<std::int64_t> result;
        std::shared_ptr<bool> available;
    };

    class label {
    public:
        label(const std::string& name);

        void begin();
         
        #ifndef SWIG
        const std::string name;
        const std::shared_ptr<bool> process_on_top;
        #endif
    private:  
        bool placed;
    };

    void process_begin();
    void process_end();

    void jump(const label& label_name);
    void branch(const future& cond, const label& label_true, const label& label_false);
    
    void ctrl_begin(const quant& q);
    void ctrl_end();
    
    void adj_begin();
    void adj_end();
    
    future measure(const quant& q);
    
    /*! \brief Apply Pauli X gate on every qubit of q.
     *
     *  \f[
     *      X = \begin{bmatrix} 0 & 1 \\
     *                          1 & 0 \end{bmatrix}
     *  \f]
     */
    void x(const quant& q);

    /*! \brief  Apply Pauli Y gate on every qubit of q.
     *
     *  \f[
     *      Y = \begin{bmatrix} 0 & -i \\
     *                          i & 0 \end{bmatrix}
     *  \f]
     */   
    void y(const quant& q);
    
    /*! \brief Apply Pauli Z gate on every qubit of q.
     *
     *  \f[
     *      Z = \begin{bmatrix} 1 & 0 \\
     *                          0 & -1 \end{bmatrix}
     *  \f]
     */   
 
    void z(const quant& q);
    
    /*! \brief Apply Hadamard gate on every qubit of q.
     *
     *  \f[
     *      H = \frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\
     *                                            1 & -1 \end{bmatrix}
     *  \f]
     */   
    void h(const quant& q);
    
    /*! \brief Apply S gate on every qubit of q.
     *
     *  \f[
     *      S = \begin{bmatrix} 1 & 0 \\
     *                          0 & i \end{bmatrix}
     *  \f]
     */   
    void s(const quant& q);
    
    /*! \brief Apply the inverse of S gate on every qubit of q.
     *
     *  \f[
     *      S^\dagger = \begin{bmatrix} 1 & 0 \\
     *                                  0 & -i \end{bmatrix}
     *  \f]
     */   
    void sd(const quant& q);
    
    /*! \brief Apply T gate on every qubit of q.
     *
     *  \f[
     *      T = \begin{bmatrix} 1 & 0 \\
     *                          0 & e^{i\pi/4} \end{bmatrix}
     *  \f]
     */   
    void t(const quant& q);
    
    /*! \brief Apply the inverse of t gate on every qubit of q.
     *
     *  \f[
     *      T^\dagger = \begin{bmatrix} 1 & 0 \\
     *                                  0 & e^{-i\pi/4} \end{bmatrix}
     *  \f]
     */   
    void td(const quant& q);
    
    /*! \brief Apply U1 gate on every qubit of q.
     *
     *  \f[ 
     *      U1 = \begin{bmatrix} 1 & 0 \\
     *                           0 & e^{i\lambda} \end{bmatrix}
     *  \f]
     *  
     *  \param lambda = \f$\lambda\f$
     */   
    void u1(double lambda, const quant& q);
    
    /*! \brief Apply U2 gate on every qubit of q.
     *
     *  \f[
     *      U2 = \begin{bmatrix} 1 & -e^{i\lambda} \\
     *                  e^{i\phi} & e^{i(\lambda+\phi)} \end{bmatrix}
     *  \f]
     * 
     *  \param phi = \f$\phi\f$
     *  \param lambda = \f$\lambda\f$
     */   
    void u2(double phi, double lambda, const quant& q);
    
    /*! \brief Apply U3 gate on every qubit of q.
     *
     *  \f[
     *      U3 = \begin{bmatrix} \cos{\theta\over2} & -e^{i\lambda}\sin{\theta\over2} \\
     *                  e^{i\phi}\sin{\theta\over2} & e^{i(\lambda+\phi)}\cos{\theta\over2}  \end{bmatrix}
     *  \f]
     * 
     *  \param theta = \f$\theta\f$
     *  \param phi = \f$\phi\f$
     *  \param lambda = \f$\lambda\f$
     */   
    void u3(double theta, double phi, double lambda, const quant& q);
    
    //! Dump the states of the qubits of q, used for debuggin.
    void dump(const quant& q);

    namespace plugin {
        void plugin(const std::string& name, const quant& q, const std::string& args);
        #ifndef SWIG
        quant pown(size_t a, const quant& x, size_t n);
        #endif
    }

    #ifndef SWIG
    template <class F, class... Args> 
    auto run(F func, Args... args) {
        process_begin();
        auto ret = func(args...);
        process_end();
        return ret;
    }

    template <class F, class... Args>
    void ctrl(const quant& q, F gate, Args... args) {
        ctrl_begin(q);
        gate(args...);
        ctrl_end();
    }

    template <class F, class... Args>
    void adj(F gate, Args... args) {
        adj_begin();
        gate(args...);
        adj_end();
    }
    
    template <class F, class... Args>
    void ctrl_adj(const quant& q, F gate, Args... args) {
        ctrl_begin(q);
        adj_begin();
        gate(args...);
        adj_end();
        ctrl_end();
    }

    template <class F>
    void qc_if(const future& test, F body) {
        label then{"if.then"};
        label end{"if.end"};

        branch(test, then, end);

        then.begin();

        body();

        jump(end);

        end.begin();
    } 
    #endif
}
