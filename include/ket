/* MIT License
 * 
 * Copyright (c) 2020 Evandro Chagas Ribeiro da Rosa <evandro.crr@posgrad.ufsc.br>
 * Copyright (c) 2020 Rafael de Santiago <r.santiago@ufsc.br>
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#pragma once
#include <unordered_map>
#include <unordered_set>
#include <cstdint>
#include <sstream>
#include <memory>
#include <vector>
#include <string>
#include <stack>
#include <stack>

namespace ket {
    class process {
    public:
        enum Gate { X, Y, Z, H, S, SD, T, TD, U1, U2, U3 };

        process();

        void exec();

        void add_inst(const std::string& inst);
        void add_gate(Gate gate, size_t qubit, std::vector<double> args = {});

        std::vector<size_t> quant(size_t size, bool dirty);

        std::tuple<size_t, std::shared_ptr<std::int64_t>, std::shared_ptr<bool>>
        measure(const std::vector<size_t>& qubits);  
        std::tuple<size_t, std::shared_ptr<std::int64_t>, std::shared_ptr<bool>>
        new_int(std::int64_t value);

        void adj_begin();
        void adj_end();

        void ctrl_begin(const std::vector<size_t>& control);
        void ctrl_end();

        size_t new_label_id();

    private:
        size_t qubit_count, future_count, label_count; 
        
        std::unordered_map<size_t,
                           std::pair<std::shared_ptr<std::int64_t>, 
                                     std::shared_ptr<bool>         >> measure_map;
        std::unordered_set<size_t> qubits_free;
        std::stack<std::stack<std::string>> adj_stack;
        std::vector<std::vector<size_t>> ctrl_stack;  
        std::stringstream kqasm;
    };

    #ifndef SWIG
    inline std::stack<std::shared_ptr<process>> process_stack;
    inline std::stack<std::shared_ptr<bool>> process_on_top_stack;

    inline std::string kbw_path;
    inline std::string plugin_path;
    inline bool use_plugin; 
    inline bool execute_kqasm;
    inline size_t exec_seed;

    inline std::string kqasm_path;
    inline bool output_kqasm;

    extern "C" void ket_init_new(int argc, char* argv[]) __attribute__((constructor));
    #endif

    struct quant {
        #ifndef SWIG
        quant(const std::vector<size_t> &qubits);
        #endif

        quant(size_t size);
        static quant dirty(size_t size);

        #ifndef SWIG
        quant operator()(int idx) const;
        #endif
        quant __getitem__(int idx) const;

        quant operator|(const quant& other) const;

        quant invert() const;

        size_t len() const;
        size_t __len__() const;

        #ifndef SWIG
        const std::vector<size_t> qubits;
        const std::shared_ptr<bool> process_on_top;
        #endif
    };

    struct future {
        #ifndef SWIG
        future(size_t id,
               const std::shared_ptr<std::int64_t>& result,
               const std::shared_ptr<bool>& available);
        #endif
        static future with(std::int64_t value);

        future operator==(const future& other) const;
        future operator!=(const future& other) const;
        future operator<(const future& other) const;
        future operator<=(const future& other) const;
        future operator>(const future& other) const;
        future operator>=(const future& other) const;

        future operator==(std::int64_t other) const;
        future operator!=(std::int64_t other) const;
        future operator<(std::int64_t  ther) const;
        future operator<=(std::int64_t  other) const;
        future operator>(std::int64_t  ther) const;
        future operator>=(std::int64_t  other) const;

        future operator+(const future& other) const;
        future operator-(const future& other) const;
        future operator*(const future& other) const;
        future operator/(const future& other) const;
        future operator<<(const future& other) const;
        future operator>>(const future& other) const;
        future operator&(const future& other) const;
        future operator^(const future& other) const;
        future operator|(const future& other) const;
        
        future operator+(std::int64_t other) const;
        future operator-(std::int64_t other) const;
        future operator*(std::int64_t other) const;
        future operator/(std::int64_t other) const;
        future operator<<(std::int64_t other) const;
        future operator>>(std::int64_t other) const;
        future operator&(std::int64_t other) const;
        future operator^(std::int64_t other) const;
        future operator|(std::int64_t other) const;

        future __radd__(std::int64_t other) const;
        future __rsub__(std::int64_t other) const;
        future __rmul__(std::int64_t other) const;
        future __rtruediv__(std::int64_t other) const;
        future __rlshift__(std::int64_t other) const;
        future __rrshift__(std::int64_t other) const;
        future __rand__(std::int64_t other) const;
        future __rxor__(std::int64_t other) const;
        future __ror__(std::int64_t other) const;

        std::int64_t get();
        void set(const future& other);

        #ifndef SWIG
        const size_t id;
        const std::shared_ptr<std::int64_t> result;
        const std::shared_ptr<bool> available;
        const std::shared_ptr<bool> process_on_top;
        #endif
    };

    struct label {
        label(const std::string& name);

        void begin() const;
         
        #ifndef SWIG
        const std::string name;
        const std::shared_ptr<bool> process_on_top;
        #endif
    };

    void process_begin();
    void process_end();

    void jump(const label& label_name);
    void branch(const future& cond, const label& label_true, label& label_false);
    
    void ctrl_begin(const quant& q);
    void ctrl_end();
    
    void adj_begin();
    void adj_end();
    
    void free(const quant& q);
    void free_dirty(const quant& q);

    future measure(quant q);

    void x(const quant& q);
    void y(const quant& q);
    void z(const quant& q);
    void h(const quant& q);
    void s(const quant& q);
    void t(const quant& q);
    void u1(double lambda, const quant& q);
    void u2(double phi, double lambda, const quant& q);
    void u3(double theta, double phi, double lambda, const quant& q);
    
    void dump(const quant& q);

    namespace plugin {
        quant pown(size_t a, const quant& x, size_t n);
    }

    #ifndef SWIG
    template <class F, class... Args> 
    auto run(F func, Args... args) {
        process_begin();
        auto ret = func(args...);
        process_end();
        return ret;
    }

    template <class F, class... Args>
    void ctrl(quant q, F gate, Args... args) {
        ctrl_begin(q);
        gate(args...);
        ctrl_end();
    }

    template <class F, class... Args>
    void adj(F gate, Args... args) {
        adj_begin();
        gate(args...);
        adj_end();
    }
    
    template <class F, class... Args>
    void ctrl_adj(quant q, F gate, Args... args) {
        ctrl_begin(q);
        adj_begin();
        gate(args...);
        adj_end();
        ctrl_end();
    }
    #endif
}
