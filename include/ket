
/* MIT License
 * 
 * Copyright (c) 2020 Evandro Chagas Ribeiro da Rosa <evandro.crr@posgrad.ufsc.br>
 * Copyright (c) 2020 Rafael de Santiago <r.santiago@ufsc.br>
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#pragma once
#include <complex>
#include <iostream> // std::cout needs to be initialized before ket::ket_init_new
#include <memory>
#include <sstream>
#include <stack>
#include <unordered_map>
#include <unordered_set>
#include <vector>

//! Main libket namespace.
namespace ket {
    #ifndef SWIG
    
    /*! \brief Manage the KQASM file generation.

     *  \class process
     *  \note
     *      You should no instance or manipulate this class directly.
     */
    class process {
    public:
    
        enum Gate { x, y, z, h, s, sd, t, td, u1, u2, u3, rx, ry, rz}; 

        /*! \brief Contructor.
         *  
         *  \note
         *      Use ket::process_begin and ket::process_end to create and
         *      destroy a instance.
         */
        process();

        /*! \brief Execute the KQASM file.
         *  
         *  Also place the result in the future instancies.
         *  
         *  \note
         *      Use future.get to trigger the quantum execution.
         */
        void exec();

        /*! \brief Place a instruction in the KQASM file.
         *  
         *  \throw
         *      std::runtime_error inside ctrl or adj scope.
         * 
         *  \worning
         *      Place undefined instruction breaks the quantum execution.
         */
        void add_inst(const std::string& inst);

        //! \brief Add a quantum gate in the KQASM file.
        void add_gate(Gate gate, size_t qubit, std::vector<double> args = {});
        
        void add_plugin(const std::string& name, const std::vector<size_t>& qubits, const std::string& args);

        /*! \brief Alloc qubits.
         *  
         *  \note
         *      Use the ket::quant constructors to allocate qubits.
         */
        std::vector<size_t> quant(size_t size, bool dirty);

        /*! \brief Measure qubits
         *
         *  \note
         *      Use ket::measure to measure a ket::quant.
         */
        std::tuple<size_t, std::shared_ptr<std::int64_t>, std::shared_ptr<bool>>
        measure(const std::vector<size_t>& qubits);  

        /*! \brief Initialize an int in the KQASM file.
         *
         *  \note
         *      Use the ket::future to instance an int in the quantum computer.
         */
        std::tuple<size_t, std::shared_ptr<std::int64_t>, std::shared_ptr<bool>>
        new_int(std::int64_t value);

        //! Place a operation between int in the KQASM file.
        std::tuple<size_t, std::shared_ptr<std::int64_t>, std::shared_ptr<bool>>
        op_int(size_t left, const std::string& op, size_t right);
        
        //! Get a dump of qubits.
        std::tuple<size_t, std::shared_ptr<std::unordered_map<std::uint64_t, std::vector<std::complex<double>>>>, std::shared_ptr<bool>>
        dump(const std::vector<size_t>& qubits);
       

        /*! \brief Initialize an inverse scope.
         *
         * \note
         *      Use ket::adj_begin to initialize an adj scope.
         */
        void adj_begin();
        
        /*! \brief End the inverse scope.
         *
         * \note
         *      Use ket::adj_end to end an adj scope.
         */
        void adj_end();

        /*! \brief Initialize a controlled scope.
         *
         * \note
         *      Use ket::ctrl_begin to initialize an ctrl scope.
         */
        void ctrl_begin(const std::vector<size_t>& control);
        
        /*! \brief End the controlled scope.
         *
         * \note
         *      Use ket::ctrl_end to end an ctrl scope.
         */
        void ctrl_end();

        /*! \brief Free qubits.
         *  
         *  \note
         *      Use quant.free to free a ket::quant. 
         */ 
        void free(size_t qubit, bool dirty);

        //! Get a new label id.
        size_t new_label_id();
        
        bool is_free(size_t qubit) const;

    private:
        size_t qubit_count, future_count, label_count, dump_count; 
        
        std::unordered_map<size_t, std::pair<std::shared_ptr<std::int64_t>, std::shared_ptr<bool>>> measure_map;
        std::unordered_map<size_t, std::pair< std::shared_ptr<std::unordered_map<std::uint64_t, std::vector<std::complex<double>>>>, std::shared_ptr<bool>>> dump_map;
        std::unordered_set<size_t> qubits_free;
        std::stack<std::stack<std::string>> adj_stack;
        std::vector<std::vector<size_t>> ctrl_stack;  
        std::stringstream kqasm;
    };

    inline std::stack<std::shared_ptr<process>> process_stack;
    inline std::stack<std::shared_ptr<bool>> process_on_top_stack; 

    inline std::string kbw_addr;
    inline int kbw_port;
    inline bool execute_kqasm;

    inline std::string kqasm_path;
    inline bool output_kqasm;
    extern "C" void ket_init_new(int argc, char* argv[]) __attribute__((constructor));
    #endif

    /*! \brief Array of qubits references.
     *  \class quant
     */
    struct quant {
        #ifndef SWIG
        quant(const std::vector<size_t> &qubits, const std::shared_ptr<bool> &ps_ot, const std::shared_ptr<process>& ps);
        #endif

        //! Alloc size qubits.
        quant(size_t size);

        /*! \brief Alloc size dirty qubits.
         *  
         *  \warning
         *      Use dirty qubits may have side effects due to previos
         *      entanglement.
         */
        static quant dirty(size_t size);

        #ifndef SWIG
        /*! \brief Return the reference for a single qubit.
         * 
         *  \note
         *      For the Python wrapper use brackets instead.
         */
        quant operator()(int idx) const;

        /*! \brief Return the reference for a range of qubits.
         * 
         *  \note
         *      For the Python wrapper use brackets instead.
         */
        quant operator()(int start, int end, int step = 1) const;
        #endif

        /*! \brief Concatenate two quant.
         * 
         *  \note
         *      The two quant needs to belong to the same process. 
         */
        quant operator|(const quant& other) const;

        //! Return a quant with qubits in the inverted order
        quant inverted() const;

        //! Return the number qubits of the quant
        size_t len() const;
        size_t __len__() const;

        /*! \brief Free the qubits
         * 
         *  \note 
         *      All qubits must be at the state \f$\left|0\right>\f$ before the call,
         *      otherwise set the dirty param to true.
         * 
         *  \warning 
         *      No check is applied to see if the qubits are at state
         *      \f$\left|0\right>\f$.
         */
        void free(bool dirty = false) const;
        
        bool is_free() const;

        #ifndef SWIG
        const std::vector<size_t> qubits;
        const std::shared_ptr<bool> process_on_top;
        const std::shared_ptr<process> ps;
        #endif
    };

    /*! \brief Refers to a integer generated in a quantum computer.
     *  \class future
     */
    class future {
    public:
        #ifndef SWIG
        future(size_t id,
               const std::shared_ptr<std::int64_t>& result,
               const std::shared_ptr<bool>& available);
        #endif

        //! Initialize a future with a value.
        future(std::int64_t value);

        future operator==(const future& other) const;
        future operator!=(const future& other) const;
        future operator<(const future& other) const;
        future operator<=(const future& other) const;
        future operator>(const future& other) const;
        future operator>=(const future& other) const;

        future operator==(std::int64_t other) const;
        future operator!=(std::int64_t other) const;
        future operator<(std::int64_t  ther) const;
        future operator<=(std::int64_t  other) const;
        future operator>(std::int64_t  ther) const;
        future operator>=(std::int64_t  other) const;

        future operator+(const future& other) const;
        future operator-(const future& other) const;
        future operator*(const future& other) const;
        future operator/(const future& other) const;
        future operator<<(const future& other) const;
        future operator>>(const future& other) const;
        future operator&(const future& other) const;
        future operator^(const future& other) const;
        future operator|(const future& other) const;
        
        future operator+(std::int64_t other) const;
        future operator-(std::int64_t other) const;
        future operator*(std::int64_t other) const;
        future operator/(std::int64_t other) const;
        future operator<<(std::int64_t other) const;
        future operator>>(std::int64_t other) const;
        future operator&(std::int64_t other) const;
        future operator^(std::int64_t other) const;
        future operator|(std::int64_t other) const;

        future __radd__(std::int64_t other) const;
        future __rsub__(std::int64_t other) const;
        future __rmul__(std::int64_t other) const;
        future __rtruediv__(std::int64_t other) const;
        future __rlshift__(std::int64_t other) const;
        future __rrshift__(std::int64_t other) const;
        future __rand__(std::int64_t other) const;
        future __rxor__(std::int64_t other) const;
        future __ror__(std::int64_t other) const;

        /*! \brief Get the integer from the quantum computer.
         *  
         *  \note
         *      This method triggers the quantum execution.
         */
        std::int64_t get();

        //! Set the future value with another future.
        void set(const future& other);

        #ifndef SWIG
        size_t get_id() const;
        const std::shared_ptr<bool> process_on_top;
        #endif

    private:
        size_t id;
        std::shared_ptr<std::int64_t> result;
        std::shared_ptr<bool> available;
    };

    /*! \brief Label for a KQASM block.
     *  \class label
     */
    class label {
    public:
        label(const std::string& name);

        //! Place the label in the KQASM file.
        void begin();
         
        #ifndef SWIG
        const std::string name;
        const std::shared_ptr<bool> process_on_top;
        #endif
    private:  
        bool placed;
    };

    //! Stack a new process.
    void process_begin();

    //! Pop a process from the stack.
    void process_end();

    //! Jump to a label in the quantum code. 
    void jump(const label& label_name);

    //! Conditional branch to a label in the quantum code. 
    void branch(const future& cond, const label& label_true, const label& label_false);

    /*! \brief Initialize a controlled scope.
     *  
     *  Every quantum gate inside are controlled by q.
     */ 
    void ctrl_begin(const quant& q);

    //! End the controlled scope.
    void ctrl_end();
    
    /*! \brief Initialize an inverse scope.
     * 
     *  The quantum operation inside the scope is executed backwards.
     */
    void adj_begin();

    //! End the inverse scope.
    void adj_end();
    
    //! Measure a quant and return a future.
    future measure(const quant& q);
    
    /*! \brief Apply Pauli X gate on every qubit of q.
     *
     *  \f[
     *      X = \begin{bmatrix} 0 & 1 \\
     *                          1 & 0 \end{bmatrix}
     *  \f]
     */
    void x(const quant& q);

    /*! \brief  Apply Pauli Y gate on every qubit of q.
     *
     *  \f[
     *      Y = \begin{bmatrix} 0 & -i \\
     *                          i & 0 \end{bmatrix}
     *  \f]
     */   
    void y(const quant& q);
    
    /*! \brief Apply Pauli Z gate on every qubit of q.
     *
     *  \f[
     *      Z = \begin{bmatrix} 1 & 0 \\
     *                          0 & -1 \end{bmatrix}
     *  \f]
     */   
 
    void z(const quant& q);
    
    /*! \brief Apply Hadamard gate on every qubit of q.
     *
     *  \f[
     *      H = \frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\
     *                                            1 & -1 \end{bmatrix}
     *  \f]
     */   
    void h(const quant& q);
    
    /*! \brief Apply S gate on every qubit of q.
     *
     *  \f[
     *      S = \begin{bmatrix} 1 & 0 \\
     *                          0 & i \end{bmatrix}
     *  \f]
     */   
    void s(const quant& q);
    
    /*! \brief Apply the inverse of S gate on every qubit of q.
     *
     *  \f[
     *      S^\dagger = \begin{bmatrix} 1 & 0 \\
     *                                  0 & -i \end{bmatrix}
     *  \f]
     */   
    void sd(const quant& q);
    
    /*! \brief Apply T gate on every qubit of q.
     *
     *  \f[
     *      T = \begin{bmatrix} 1 & 0 \\
     *                          0 & e^{i\pi/4} \end{bmatrix}
     *  \f]
     */   
    void t(const quant& q);
    
    /*! \brief Apply the inverse of t gate on every qubit of q.
     *
     *  \f[
     *      T^\dagger = \begin{bmatrix} 1 & 0 \\
     *                                  0 & e^{-i\pi/4} \end{bmatrix}
     *  \f]
     */   
    void td(const quant& q);
    
    /*! \brief Apply U1 gate on every qubit of q.
     *
     *  \f[ 
     *      U1(\lambda) = \begin{bmatrix} 1 & 0 \\
     *                                    0 & e^{i\lambda} \end{bmatrix}
     *  \f]
     *  
     *  \param lambda \f$\lambda\f$
     */   
    void u1(double lambda, const quant& q);
    
    /*! \brief Apply U2 gate on every qubit of q.
     *
     *  \f[
     *      U2(\phi, \lambda) =
     *          \frac{1}{\sqrt{2}}\begin{bmatrix} 1 & -e^{i\lambda} \\
     *                                    e^{i\phi} & e^{i(\lambda+\phi)} \end{bmatrix}
     *  \f]
     * 
     *  \param phi \f$\phi\f$
     *  \param lambda \f$\lambda\f$
     */   
    void u2(double phi, double lambda, const quant& q);
    
    /*! \brief Apply U3 gate on every qubit of q.
     *
     *  \f[
     *      U3(\theta, \phi, \lambda) =
     *          \begin{bmatrix} \cos{\frac{\theta}{2}} & -e^{i\lambda}\sin{\frac{\theta}{2}} \\
     *                 e^{i\phi}\sin{\frac{\theta}{2}} & e^{i(\lambda+\phi)}\cos{\frac{\theta}{2}}  \end{bmatrix}
     *  \f]
     * 
     *  \param theta \f$\theta\f$
     *  \param phi \f$\phi\f$
     *  \param lambda \f$\lambda\f$
     */   
    void u3(double theta, double phi, double lambda, const quant& q);
      
    /*! \brief Apply a rotation about the X axis on every qubit of q.
     *
     *  \f[ 
     *       RX(\theta) = U3(\theta, -\pi/2, \pi/2) = 
     *                   \begin{bmatrix} \cos{\frac{\theta}{2}} & -i\sin{\frac{\theta}{2}} \\
     *                                 -i\sin{\frac{\theta}{2}} & \cos{\frac{\theta}{2}} \end{bmatrix}
     *  \f]
     * 
     *  \param theta \f$\theta\f$
     */   
    void rx(double theta, const quant& q);

    /*! \brief Apply a rotation about the Y axis on every qubit of q.
     *
     *  \f[ 
     *      RY(\theta) = U3(\theta, 0, 0) =
     *                   \begin{bmatrix} \cos{\frac{\theta}{2}} & -\sin{\frac{\theta}{2}} \\
     *                                   \sin{\frac{\theta}{2}} & \cos{\frac{\theta}{2}} \end{bmatrix}
     *  \f]
     * 
     *  \param theta \f$\theta\f$
     */   
    void ry(double theta, const quant& q);

     /*! \brief Apply a rotation about the Z axis on every qubit of q.
     *
     *  \f[ 
     *      RZ(\theta) =
     *           \begin{bmatrix} e^{-i\theta/2} & 0 \\
     *                                        0 & e^{i\theta/2} \end{bmatrix}
     *  \f]
     * 
     *  \param theta \f$\theta\f$
     */   
    void rz(double theta, const quant& q);
    
    //! Dump the states of the qubits of q, used for debuggin.
    class dump {
    public:

        //! Dump the state of a quantum.
        dump(const quant& q);

        //! Return a list of basis states.
        std::vector<unsigned long long> get_states();

        //! Return a list of amplitudes of a state. 
        std::vector<std::complex<double>> amplitude(size_t idx);
        
        //! Return the probability of measure a state.
        double probability(size_t idx);
        
        //! Return a string to print the quantum state.
        std::string show(std::string format = "");

        void get();

        bool operator==(dump& other);
        bool operator!=(dump& other);

        const size_t nbits;
    private:
        const std::shared_ptr<bool> process_on_top;

        size_t id;
        std::shared_ptr<std::unordered_map<std::uint64_t, std::vector<std::complex<double>>>> states;
        std::shared_ptr<bool> available;
    };

    //! Execute the top process
    void exec_quantum();

    namespace plugin {
        /*! \brief Execute a Ket Bitwise plugin.
         *   
         *  The plugin must be acessable by the plugin path.
         *  All qubits are considered entangled after the plugin execution.  
         * 
         *  \param name math lib<name>.so
         *  \param q qubits affected by the plugin
         *  \param args arguments for the plugin
         */
        void plugin(const std::string& name, const quant& q, const std::string& args);
        
        /*! \brief Apply a modular exponentiation in a superposition.
         *
         *  \f[
         *      \left|x\\right>\left|0\\right> \\rightarrow  \left|x\\right>\left|a^x\;\\text{mod}\,n\\right>
         *  \f] 
         * 
         *  \return Quant with the result of the operation.
         */
        quant pown(size_t a, const quant& x, size_t n);
        
        void diagonal(std::vector<double> diag, const quant& q);
    }

    #ifndef SWIG
    //! Run function in a new process.
    template <class F, class... Args> 
    auto run(F func, Args... args) {
        process_begin();
        auto ret = func(args...);
        process_end();
        return ret;
    }

    //! Add qubits of control to a function.
    template <class F, class... Args>
    void ctrl(const quant& q, F gate, Args... args) {
        ctrl_begin(q);
        gate(args...);
        ctrl_end();
    }

    //! Call the inverse of a function.
    template <class F, class... Args>
    void adj(F gate, Args... args) {
        adj_begin();
        gate(args...);
        adj_end();
    }
    
    //! Call the inverse of a function adding qubits of controll.
    template <class F, class... Args>
    void ctrl_adj(const quant& q, F gate, Args... args) {
        ctrl_begin(q);
        adj_begin();
        gate(args...);
        adj_end();
        ctrl_end();
    }

    //! If statement that runs on the quantum computer.
    template <class F>
    void qc_if(const future& test, F body) {
        label then{"if.then"};
        label end{"if.end"};

        branch(test, then, end);

        then.begin();

        body();

        jump(end);

        end.begin();
    } 
    #endif
}
