/* MIT License
 * 
 * Copyright (c) 2020 Evandro Chagas Ribeiro da Rosa <evandro.crr@posgrad.ufsc.br>
 * Copyright (c) 2020 Rafael de Santiago <r.santiago@ufsc.br>
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#pragma once
#include <cstddef>
#include <cstdint>
#include <string>
#include <memory>
#include <functional>

namespace ket {

    struct quant {
        quant(const std::shared_ptr<void> &quant_ptr);

        quant operator()(size_t idx) const;
        quant operator|(quant other) const;
        quant invert() const;
        size_t len() const;
        size_t __len__() const;

        std::shared_ptr<void> quant_ptr;
    };

    struct future {
        future(const std::shared_ptr<void> &future_ptr);

        future operator==(const future& other) const;
        future operator!=(const future& other) const;
        future operator<(const future& other) const;
        future operator<=(const future& other) const;
        future operator>(const future& other) const;
        future operator>=(const future& other) const;

        future operator==(std::int64_t other) const;
        future operator!=(std::int64_t other) const;
        future operator<(std::int64_t  ther) const;
        future operator<=(std::int64_t  other) const;
        future operator>(std::int64_t  ther) const;
        future operator>=(std::int64_t  other) const;

        future operator+(const future& other) const;
        future operator-(const future& other) const;
        future operator*(const future& other) const;
        future operator/(const future& other) const;
        future operator<<(const future& other) const;
        future operator>>(const future& other) const;
        future operator&(const future& other) const;
        future operator^(const future& other) const;
        future operator|(const future& other) const;
        
        future operator+(std::int64_t other) const;
        future operator-(std::int64_t other) const;
        future operator*(std::int64_t other) const;
        future operator/(std::int64_t other) const;
        future operator<<(std::int64_t other) const;
        future operator>>(std::int64_t other) const;
        future operator&(std::int64_t other) const;
        future operator^(std::int64_t other) const;
        future operator|(std::int64_t other) const;

        future __radd__(std::int64_t other) const;
        future __rsub__(std::int64_t other) const;
        future __rmul__(std::int64_t other) const;
        future __rtruediv__(std::int64_t other) const;
        future __rlshift__(std::int64_t other) const;
        future __rrshift__(std::int64_t other) const;
        future __rand__(std::int64_t other) const;
        future __rxor__(std::int64_t other) const;
        future __ror__(std::int64_t other) const;

        std::int64_t get();

        std::shared_ptr<void> future_ptr;
    };

    struct process {
        process();
        std::shared_ptr<void> ps;
    };
}

#ifndef SWIG
extern "C" {
    inline ket::process* ket_ps;
    inline char* ket_kbw_path;
    inline int ket_no_execute;
    inline size_t ket_seed;
    inline char* ket_kqasm_path;
    inline char* ket_plugin_path;
    void ket_init_new(int argc, char* argv[]) __attribute__((constructor));
    void ket_init_free() __attribute__((destructor));
} 
#endif

namespace ket {
    
    class label {
    public:
        label(const std::string& name, process& ps = *ket_ps);
        operator std::string() const;

        void begin();

         
        process& ps;
    private:
        std::string name;
        inline static size_t count = 0;
    };

    void jump(label& label_name);
    void branch(future cond, label& label_true, label& label_false);
    
    void ctrl_begin(quant q);
    void ctrl_end(quant q);
    
    void adj_begin(process &ps = *ket_ps);
    void adj_end(process &ps = *ket_ps);
    
    void ctrl_adj_begin(quant q);
    void ctrl_adj_end(quant q);

    quant alloc(size_t size, process &ps = *ket_ps);
    quant alloc_dirty(size_t size, process &ps = *ket_ps);

    void free(quant q);
    void free_dirty(quant q);

    future measure(quant q, bool wait = true);
    void wait(process &ps = *ket_ps);

    void x(quant q);
    void y(quant q);
    void z(quant q);
    void h(quant q);
    void s(quant q);
    void t(quant q);
    void u1(double lambda, quant q);
    void u2(double phi, double lambda, quant q);
    void u3(double theta, double phi, double lambda, quant q);
    
    void dump(quant q);

    quant pown(size_t a, quant x, size_t n);

    #ifndef SWIG
    template <class F, class... Args> 
    auto run(F func, Args... args) {
        auto* backup_ket_ps = ket_ps;
        ket_ps = new process;
        auto ret = func(args...);
        delete ket_ps;
        ket_ps = backup_ket_ps;
        return ret;
    }

    template <class F, class... Args>
    void ctrl(quant q, F gate, Args... args) {
        ctrl_begin(q);
        gate(args...);
        ctrl_end(q);
    }

    template <class F, class... Args>
    void adj(F gate, Args... args) {
        adj_begin();
        gate(args...);
        adj_end();
    }
    
    template <class F, class... Args>
    void ctrl_adj(quant q, F gate, Args... args) {
        ctrl_adj_begin(q);
        gate(args...);
        ctrl_adj_end(q);
    }

    void if_then(future cond, std::function<void(void)> then, std::function<void(void)> otherwise = nullptr, process& ps = *ket_ps);
    #endif
}
